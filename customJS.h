const char* customJS = 
"// redraw the label as a table and a canvas.\n"
"// the table has two rows. the top row are the bit values\n"
"// and the bottom row is the second within the minute.\n"
"// the canvas shows the logical high/low pin values.\n"
"// TODO rename function\n"
"// TODO rename spanElement -> element\n"
"function convertToTable(spanElement) { \n"
"    \n"
"    const characters = Array.from(spanElement.innerHTML);\n"
"\n"
"    // --- 2. Generate and temporarily insert the Table for accurate measurement ---\n"
"\n"
"    // Temporarily clear the span and make it a block container for measurement\n"
"    spanElement.innerHTML = '';\n"
"    spanElement.classList.add('visualized-container'); \n"
"    \n"
"    let dataRowContent = '<tr>';\n"
"    characters.forEach(char => {\n"
"        dataRowContent += `<td>${char}</td>`;\n"
"    });\n"
"    dataRowContent += '</tr>';\n"
"\n"
"    let indexRowContent = '<tr>';\n"
"    characters.forEach((char, index) => {\n"
"        indexRowContent += `<th>${index}</th>`;\n"
"    });\n"
"    indexRowContent += '</tr>';\n"
"\n"
"    // Use a temporary ID for easy selection\n"
"    let tableHTML = '<table id=\"tempVisualTable\" class=\"char-table\">';\n"
"    tableHTML += '<tbody>' + dataRowContent + '</tbody>'; \n"
"    tableHTML += '<tfoot>' + indexRowContent + '</tfoot>'; \n"
"    tableHTML += '</table>';\n"
"\n"
"    // Insert temporarily into the span (which is now the container)\n"
"    spanElement.innerHTML = tableHTML;\n"
"    const table = document.getElementById('tempVisualTable'); \n"
"    \n"
"    // --- 3. Measure Dimensions using Layout Properties (offsetLeft/offsetWidth) ---\n"
"\n"
"    const charCells = Array.from(table.querySelector('tbody tr').children);\n"
"    \n"
"    // Store cell widths, left positions, and character data for drawing\n"
"    const cellDimensions = charCells.map((cell, index) => {\n"
"        return {\n"
"            // offsetLeft provides the integer x-coordinate relative to the table (parent is the span)\n"
"            left: cell.offsetLeft, \n"
"            // offsetWidth provides the integer width including padding and borders\n"
"            width: cell.offsetWidth, \n"
"            char: characters[index]\n"
"        };\n"
"    });\n"
"    \n"
"    // --- 4. Create and configure the Canvas ---\n"
"\n"
"    const canvas = document.createElement('canvas');\n"
"    canvas.width = table.offsetWidth; \n"
"    canvas.height = 40;\n"
"    const ctx = canvas.getContext('2d');\n"
"    \n"
"    // --- 5. Drawing Logic using Measured Integer Coordinates ---\n"
"\n"
"    const baseLine = canvas.height; // The bottom of the canvas\n"
"    const smallBoxHeight = 2; // 2px high box\n"
"\n"
"    cellDimensions.forEach(dim => {\n"
"        const char = dim.char;\n"
"        const startX = dim.left;\n"
"        const cellWidth = dim.width;\n"
"\n"
"        // Drawing is bottom-aligned (y-coordinate is relative to baseLine)\n"
"        if (char === 'M') {\n"
"            // M: 2px high (80% left), full height (20% right)\n"
"            \n"
"            // Use Math.round() for the split point to ensure integer width segments\n"
"            const width80 = Math.round(cellWidth * 0.8);\n"
"            const width20 = cellWidth - width80; // Guaranteed to fill the rest of the cell\n"
"\n"
"            // Box 1 (2px high, 80% width, left)\n"
"            ctx.fillRect(startX, baseLine - smallBoxHeight, width80, smallBoxHeight);\n"
"\n"
"            // Box 2 (Full height, 20% width, right)\n"
"            ctx.fillRect(startX + width80, baseLine - canvas.height, width20, canvas.height);\n"
"\n"
"        } else if (char === '0') {\n"
"            // 0: 2px high (20% left), full height (80% right)\n"
"\n"
"            const width20 = Math.round(cellWidth * 0.2);\n"
"            const width80 = cellWidth - width20; // Guaranteed to fill the rest of the cell\n"
"            \n"
"            // Box 1 (2px high, 20% width, left)\n"
"            ctx.fillRect(startX, baseLine - smallBoxHeight, width20, smallBoxHeight);\n"
"\n"
"            // Box 2 (Full height, 80% width, right)\n"
"            ctx.fillRect(startX + width20, baseLine - canvas.height, width80, canvas.height);\n"
"\n"
"        } else if (char === '1') {\n"
"            // 1: 2px high (50% left), full height (50% right)\n"
"            \n"
"            const width50_left = Math.round(cellWidth / 2);\n"
"            const width50_right = cellWidth - width50_left; // Guaranteed to fill the rest of the cell\n"
"\n"
"            // Box 1 (2px high, 50% width, left)\n"
"            ctx.fillRect(startX, baseLine - smallBoxHeight, width50_left, smallBoxHeight);\n"
"\n"
"            // Box 2 (Full height, 50% width, right)\n"
"            ctx.fillRect(startX + width50_left, baseLine - canvas.height, width50_right, canvas.height);\n"
"        }\n"
"        // For other values (including spaces), draw nothing.\n"
"    });\n"
"    \n"
"    // --- 6. Final DOM Update ---\n"
"\n"
"    // Clear the span again (removing the temporary table)\n"
"    spanElement.innerHTML = '';  // TODO why? why not just add the canvas above?\n"
"    \n"
"    // Re-inject the canvas and the table in order\n"
"    spanElement.appendChild(canvas);\n"
"    \n"
"    // Remove temporary ID before final insertion\n"
"    spanElement.appendChild(table);\n"
"}\n"
"\n"
"// TODO consolidate document.getElementById(l4)\n"
"// re-draw the label every time it is updated\n"
"var observer = new MutationObserver(mutationsList => {\n"
"    observer.disconnect();\n"
"    convertToTable(document.getElementById('l4'));\n"
"    observer.observe(document.getElementById('l4'), {childList:true});\n"
"});\n"
"\n"
"// enable our observer after all the page content is loaded\n"
"window.addEventListener('load', function() {\n"
"  observer.observe(document.getElementById('l4'),{childList:true});\n"
"});\n";